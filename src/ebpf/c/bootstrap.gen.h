/* ========================================================================== */
/*                           GENERATED FILE                                   */
/* ========================================================================== */
/*                                                                            */
/*  This file is automatically generated from bootstrap.templ.h               */
/*  DO NOT EDIT MANUALLY - changes will be overwritten                        */
/*                                                                            */
/*  Generator: ebpf/typegen/typegen.rs                                        */
/*  Template:  ebpf/c/bootstrap.templ.h                                       */
/*  Config:    ebpf/typegen/events.toml                                       */
/*                                                                            */
/*  To regenerate: `cd tracer-client/src/ebpf/c && make` (fast)               */
/*  Alternative:   `cd tracer-client && cargo build` (slower)                 */
/*                                                                            */
/* ========================================================================== */

#ifndef BOOTSTRAP_H
#define BOOTSTRAP_H

typedef unsigned long long u64;
typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;

// Map configuration constants
#define CONFIG_MAP_MAX_ENTRIES 64             // 64 * 8 bytes for blacklist, config settings, etc
#define RINGBUF_MAX_ENTRIES (256 * 1024)      // 256KB * sizeof(event_header_kernel)
#define PAYLOAD_BUFFER_N_PAGES 256            // 256 * 4KB = 1MB
#define PAYLOAD_FLUSH_MAX_PAGES 16            // 16 * 4KB = 64KB max flush size
#define PAYLOAD_FLUSH_TIMEOUT_NS 750000000ULL // 750 milliseconds (latency upper bound)

// Memory and string size constants
#define TASK_COMM_LEN 16  // Non-essential value, possibly trimmed
#define PAGE_SIZE 4096    // 4KB, (matches standard Intel/ARM page size)
#define ARGV_MAX_SIZE 384 // 256+128 bytes (uses 75% of available in-kernel memory)
#define FILENAME_MAX_SIZE 384

// Map keys for configuration values
#define CONFIG_PID_BLACKLIST_0 0
// CONFIG_PID_BLACKLIST_0..31 implicitly defined as CONFIG_PID_BLACKLIST_0 + 0..MAX_BLACKLIST_ENTRIES
#define MAX_BLACKLIST_ENTRIES 32
#define CONFIG_DEBUG_ENABLED 32
#define CONFIG_SYSTEM_BOOT_NS 33 // Needed for timestamps

// The exact values for event IDs are chosen arbitrarily, but should stay consistent between Tracer versions
enum event_type
{
  event_type_sched_sched_process_exec = 0,
  event_type_sched_sched_process_exit = 1,
  event_type_sched_psi_memstall_enter = 16,
  event_type_syscalls_sys_enter_openat = 1024,
  event_type_syscalls_sys_exit_openat = 1025,
  event_type_syscalls_sys_enter_read = 1026,
  event_type_syscalls_sys_enter_write = 1028,
  event_type_vmscan_mm_vmscan_direct_reclaim_begin = 2048,
  event_type_oom_mark_victim = 3072,
};

// Attributes common to every event
struct event_header_user
{
  u64 event_id;
  enum event_type event_type;
  u64 timestamp_ns;
  u32 pid;
  u32 ppid;
  u64 upid;
  u64 uppid;
  char comm[TASK_COMM_LEN];
  void *payload;
} __attribute__((packed));
struct event_header_kernel
{
  struct
  {
    u16 cpu;          // CPU where the payload is captured
    u16 page_index;   // Index of page in per-CPU array
    u16 byte_offset;  // Offset within page
    u16 flush_signal; // Number of pages to flush from kernel to userspace
  } payload;
  enum event_type event_type;
  u64 timestamp_ns;
  u32 pid;
  u32 ppid;
  u64 upid;
  u64 uppid;
  char comm[TASK_COMM_LEN];
} __attribute__((packed));

// Target format for long strings and arrays,
// created in-between kernel->userspace and userspace->external flush
struct flex_buf
{
  u32 byte_length;
  char data[]; // Flexible Array Member (FAM)
};

// Process execution (successful)
struct payload_user_sched_sched_process_exec
{
  struct flex_buf* argv;
};
struct payload_kernel_sched_sched_process_exec
{
  u64 argv; // From buf_malloc_dyn
};

// Process termination (successful)
struct payload_user_sched_sched_process_exit
{
  u32 exit_code;
};
struct payload_kernel_sched_sched_process_exit
{
  u32 exit_code;
};

// Memory pressure, stall begins
struct payload_user_sched_psi_memstall_enter
{
  char _unused; // Empty payload
};
struct payload_kernel_sched_psi_memstall_enter
{
  char _unused; // Empty payload
};

// File open, syscall entry
struct payload_user_syscalls_sys_enter_openat
{
  u32 dfd;
  struct flex_buf* filename;
  u32 flags;
  u32 mode;
};
struct payload_kernel_syscalls_sys_enter_openat
{
  u32 dfd;
  u64 filename; // From buf_malloc_dyn
  u32 flags;
  u32 mode;
};

// File open, syscall return
struct payload_user_syscalls_sys_exit_openat
{
  u32 fd;
};
struct payload_kernel_syscalls_sys_exit_openat
{
  u32 fd;
};

// Files and pipes, read syscall entry
struct payload_user_syscalls_sys_enter_read
{
  u32 fd;
  u64 count;
};
struct payload_kernel_syscalls_sys_enter_read
{
  u32 fd;
  u64 count;
};

// Files and pipes, write syscall entry
struct payload_user_syscalls_sys_enter_write
{
  u32 fd;
  u64 count;
  struct flex_buf* content;
};
struct payload_kernel_syscalls_sys_enter_write
{
  u32 fd;
  u64 count;
  u64 content; // From buf_malloc_dyn
};

// Memory pressure, reclaim begins
struct payload_user_vmscan_mm_vmscan_direct_reclaim_begin
{
  u32 order;
};
struct payload_kernel_vmscan_mm_vmscan_direct_reclaim_begin
{
  u32 order;
};

// Memory pressure, OOM killer selects process
struct payload_user_oom_mark_victim
{
  char _unused; // Empty payload
};
struct payload_kernel_oom_mark_victim
{
  char _unused; // Empty payload
};


// Helper for collapsing kernel-provided allocation chains into a single node
struct dar_array
{
  u32 length;
  u64 *data; // pointers to root descriptors
};

static inline struct dar_array payload_to_dynamic_allocation_roots(enum event_type t, void *ptr)
{
  struct dar_array result = {0, NULL};
  switch (t)
  {
  case event_type_sched_sched_process_exec:
  {
    struct payload_user_sched_sched_process_exec *p = (struct payload_user_sched_sched_process_exec *)ptr;
    static u64 roots[1];
    roots[0] = (u64)&p->argv;
    result.length = 1;
    result.data = roots;
    break;
  }
  case event_type_syscalls_sys_enter_openat:
  {
    struct payload_user_syscalls_sys_enter_openat *p = (struct payload_user_syscalls_sys_enter_openat *)ptr;
    static u64 roots[1];
    roots[0] = (u64)&p->filename;
    result.length = 1;
    result.data = roots;
    break;
  }
  case event_type_syscalls_sys_enter_write:
  {
    struct payload_user_syscalls_sys_enter_write *p = (struct payload_user_syscalls_sys_enter_write *)ptr;
    static u64 roots[1];
    roots[0] = (u64)&p->content;
    result.length = 1;
    result.data = roots;
    break;
  }
  default:
    break;
  }
  return result;
}

// For the statically measurable part of payloads only
static inline size_t get_kernel_payload_size(enum event_type t)
{
  switch (t)
  {
  case event_type_sched_sched_process_exec:
    return sizeof(struct payload_kernel_sched_sched_process_exec);
  case event_type_sched_sched_process_exit:
    return sizeof(struct payload_kernel_sched_sched_process_exit);
  case event_type_sched_psi_memstall_enter:
    return sizeof(struct payload_kernel_sched_psi_memstall_enter);
  case event_type_syscalls_sys_enter_openat:
    return sizeof(struct payload_kernel_syscalls_sys_enter_openat);
  case event_type_syscalls_sys_exit_openat:
    return sizeof(struct payload_kernel_syscalls_sys_exit_openat);
  case event_type_syscalls_sys_enter_read:
    return sizeof(struct payload_kernel_syscalls_sys_enter_read);
  case event_type_syscalls_sys_enter_write:
    return sizeof(struct payload_kernel_syscalls_sys_enter_write);
  case event_type_vmscan_mm_vmscan_direct_reclaim_begin:
    return sizeof(struct payload_kernel_vmscan_mm_vmscan_direct_reclaim_begin);
  case event_type_oom_mark_victim:
    return sizeof(struct payload_kernel_oom_mark_victim);
  default:
    return 0;
  }
}

// -------
// Helpers for printing as JSON (in example.cpp)
// -------

static inline const char* event_type_to_string(enum event_type t)
{
  switch (t)
  {
  case event_type_sched_sched_process_exec:
    return "sched/sched_process_exec";
  case event_type_sched_sched_process_exit:
    return "sched/sched_process_exit";
  case event_type_sched_psi_memstall_enter:
    return "sched/psi_memstall_enter";
  case event_type_syscalls_sys_enter_openat:
    return "syscalls/sys_enter_openat";
  case event_type_syscalls_sys_exit_openat:
    return "syscalls/sys_exit_openat";
  case event_type_syscalls_sys_enter_read:
    return "syscalls/sys_enter_read";
  case event_type_syscalls_sys_enter_write:
    return "syscalls/sys_enter_write";
  case event_type_vmscan_mm_vmscan_direct_reclaim_begin:
    return "vmscan/mm_vmscan_direct_reclaim_begin";
  case event_type_oom_mark_victim:
    return "oom/mark_victim";
  default:
    return "unknown";
  }
}

struct kv_entry
{
  char type[32]; // eg, "u32"
  char key[32];  // eg, "filename"
  void *value;
};

struct kv_array
{
  u32 length;
  struct kv_entry *data;
};

static inline struct kv_array payload_to_kv_array(enum event_type t, void *ptr)
{
  struct kv_array result = {0, NULL};
  switch (t)
  {
  case event_type_sched_sched_process_exec:
  {
    struct payload_user_sched_sched_process_exec *p = (struct payload_user_sched_sched_process_exec *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "char[][]");
    strcpy(entries[0].key, "argv");
    entries[0].value = &p->argv;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_sched_sched_process_exit:
  {
    struct payload_user_sched_sched_process_exit *p = (struct payload_user_sched_sched_process_exit *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "exit_code");
    entries[0].value = &p->exit_code;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_sched_psi_memstall_enter:
    break;
  case event_type_syscalls_sys_enter_openat:
  {
    struct payload_user_syscalls_sys_enter_openat *p = (struct payload_user_syscalls_sys_enter_openat *)ptr;
    static struct kv_entry entries[4];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "dfd");
    entries[0].value = &p->dfd;
    strcpy(entries[1].type, "char[]");
    strcpy(entries[1].key, "filename");
    entries[1].value = &p->filename;
    strcpy(entries[2].type, "u32");
    strcpy(entries[2].key, "flags");
    entries[2].value = &p->flags;
    strcpy(entries[3].type, "u32");
    strcpy(entries[3].key, "mode");
    entries[3].value = &p->mode;
    result.length = 4;
    result.data = entries;
    break;
  }
  case event_type_syscalls_sys_exit_openat:
  {
    struct payload_user_syscalls_sys_exit_openat *p = (struct payload_user_syscalls_sys_exit_openat *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "fd");
    entries[0].value = &p->fd;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_syscalls_sys_enter_read:
  {
    struct payload_user_syscalls_sys_enter_read *p = (struct payload_user_syscalls_sys_enter_read *)ptr;
    static struct kv_entry entries[2];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "fd");
    entries[0].value = &p->fd;
    strcpy(entries[1].type, "u64");
    strcpy(entries[1].key, "count");
    entries[1].value = &p->count;
    result.length = 2;
    result.data = entries;
    break;
  }
  case event_type_syscalls_sys_enter_write:
  {
    struct payload_user_syscalls_sys_enter_write *p = (struct payload_user_syscalls_sys_enter_write *)ptr;
    static struct kv_entry entries[3];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "fd");
    entries[0].value = &p->fd;
    strcpy(entries[1].type, "u64");
    strcpy(entries[1].key, "count");
    entries[1].value = &p->count;
    strcpy(entries[2].type, "char[]");
    strcpy(entries[2].key, "content");
    entries[2].value = &p->content;
    result.length = 3;
    result.data = entries;
    break;
  }
  case event_type_vmscan_mm_vmscan_direct_reclaim_begin:
  {
    struct payload_user_vmscan_mm_vmscan_direct_reclaim_begin *p = (struct payload_user_vmscan_mm_vmscan_direct_reclaim_begin *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "order");
    entries[0].value = &p->order;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_oom_mark_victim:
    break;
  default:
    break;
  }
  return result;
}

#endif /* BOOTSTRAP_H */
