/* ========================================================================== */
/*                           GENERATED FILE                                   */
/* ========================================================================== */
/*                                                                            */
/*  This file is automatically generated from bootstrap.templ.h               */
/*  DO NOT EDIT MANUALLY - changes will be overwritten                        */
/*                                                                            */
/*  Generator: ebpf/typegen/typegen.rs                                        */
/*  Template:  ebpf/c/bootstrap.templ.h                                       */
/*  Config:    ebpf/typegen/events.toml                                       */
/*                                                                            */
/*  To regenerate: `cd tracer-client/src/ebpf/c && make` (fast)               */
/*  Alternative:   `cd tracer-client && cargo build` (slower)                 */
/*                                                                            */
/* ========================================================================== */

#ifndef BOOTSTRAP_H
#define BOOTSTRAP_H

#include <string.h>

typedef unsigned long long u64;
typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;

// Map configuration constants
#define CONFIG_MAP_MAX_ENTRIES 64                    // 64 * 8 bytes for blacklist, config settings, etc
#define RINGBUF_MAX_ENTRIES (256 * 1024)             // 256KB * sizeof(event_header_kernel)
#define PAYLOAD_BUFFER_ENTRY_SIZE 64                 // 64 bytes (smallest unit allowing fast copies)
#define PAYLOAD_BUFFER_N_ENTRIES_PER_CPU (16 * 1024) // 16 * 1024 * sizeof(entry) = 1MB
#define PAYLOAD_FLUSH_TIMEOUT_NS 750000000ULL        // 750 milliseconds (latency upper bound)
#define MAX_CPUS 256                                 // Maximum CPUs supported for manual per-CPU isolation
#define F_READ_NUL_TERMINATED (1ULL << 32)           // Flag for read_into_payload()

// Memory and string size constants
#define TASK_COMM_LEN 16  // Non-essential value, possibly trimmed
#define ARGV_MAX_SIZE 384 // 256+128 bytes (uses 75% of available in-kernel memory)
#define FILENAME_MAX_SIZE 384
#define WRITE_CONTENT_MAX_SIZE 32768 // Maximum bytes to capture from stdout/stderr

// Map keys for configuration values
#define CONFIG_PID_BLACKLIST_0 0
// CONFIG_PID_BLACKLIST_0..31 implicitly defined as CONFIG_PID_BLACKLIST_0 + 0..MAX_BLACKLIST_ENTRIES
#define MAX_BLACKLIST_ENTRIES 32
#define CONFIG_DEBUG_ENABLED 32
#define CONFIG_SYSTEM_BOOT_NS 33 // Needed for timestamps

// The exact values for event IDs are chosen arbitrarily, but should stay consistent between Tracer versions
enum event_type
{
  event_type_sched_sched_process_exec = 0,
  event_type_sched_sched_process_exit = 1,
  event_type_sched_psi_memstall_enter = 16,
  event_type_syscalls_sys_enter_openat = 1024,
  event_type_syscalls_sys_exit_openat = 1025,
  event_type_syscalls_sys_enter_read = 1026,
  event_type_syscalls_sys_enter_write = 1028,
  event_type_vmscan_mm_vmscan_direct_reclaim_begin = 2048,
  event_type_oom_mark_victim = 3072,
};

// Attributes common to every event
struct event_header_user
{
  u64 event_id;
  enum event_type event_type;
  u64 timestamp_ns;
  u32 pid;
  u32 ppid;
  u64 upid;
  u64 uppid;
  char comm[TASK_COMM_LEN];
  void *payload;
} __attribute__((packed));
struct event_header_kernel
{
  struct
  {
    u32 start_index;
    u32 end_index;
  } payload;
  enum event_type event_type;
  u64 timestamp_ns;
  u32 pid;
  u32 ppid;
  u64 upid;
  u64 uppid;
  char comm[TASK_COMM_LEN];
} __attribute__((packed));

struct flex_buf
{
  u32 byte_length;
  char *data;
} __attribute__((packed));

// Process execution (successful)
struct payload_user_sched_sched_process_exec
{
  struct flex_buf argv;
} __attribute__((packed));
struct payload_kernel_sched_sched_process_exec
{
  u64 argv; // Descriptor from buf_malloc_dyn
  u32 _argv_unused; // Padding
} __attribute__((packed));

// Process termination (successful)
struct payload_user_sched_sched_process_exit
{
  u32 exit_code;
} __attribute__((packed));
struct payload_kernel_sched_sched_process_exit
{
  u32 exit_code;
} __attribute__((packed));

// Memory pressure, stall begins
struct payload_user_sched_psi_memstall_enter
{
  char _unused; // Empty payload
} __attribute__((packed));
struct payload_kernel_sched_psi_memstall_enter
{
  char _unused; // Empty payload
} __attribute__((packed));

// File open, syscall entry
struct payload_user_syscalls_sys_enter_openat
{
  u32 dfd;
  struct flex_buf filename;
  u32 flags;
  u32 mode;
} __attribute__((packed));
struct payload_kernel_syscalls_sys_enter_openat
{
  u32 dfd;
  u64 filename; // Descriptor from buf_malloc_dyn
  u32 _filename_unused; // Padding
  u32 flags;
  u32 mode;
} __attribute__((packed));

// File open, syscall return
struct payload_user_syscalls_sys_exit_openat
{
  u32 fd;
} __attribute__((packed));
struct payload_kernel_syscalls_sys_exit_openat
{
  u32 fd;
} __attribute__((packed));

// Files and pipes, read syscall entry
struct payload_user_syscalls_sys_enter_read
{
  u32 fd;
  u64 count;
} __attribute__((packed));
struct payload_kernel_syscalls_sys_enter_read
{
  u32 fd;
  u64 count;
} __attribute__((packed));

// Files and pipes, write syscall entry
struct payload_user_syscalls_sys_enter_write
{
  u32 fd;
  u64 count;
  struct flex_buf content;
} __attribute__((packed));
struct payload_kernel_syscalls_sys_enter_write
{
  u32 fd;
  u64 count;
  u64 content; // Descriptor from buf_malloc_dyn
  u32 _content_unused; // Padding
} __attribute__((packed));

// Memory pressure, reclaim begins
struct payload_user_vmscan_mm_vmscan_direct_reclaim_begin
{
  u32 order;
} __attribute__((packed));
struct payload_kernel_vmscan_mm_vmscan_direct_reclaim_begin
{
  u32 order;
} __attribute__((packed));

// Memory pressure, OOM killer selects process
struct payload_user_oom_mark_victim
{
  u32 _unused;
} __attribute__((packed));
struct payload_kernel_oom_mark_victim
{
  u32 _unused;
} __attribute__((packed));


// Helper for collapsing kernel-provided allocation chains into a single node
struct dar_array
{
  u32 length;
  u64 *data; // pointers to root descriptors
};

// Get pointers to dynamic payload attributes (ie, strings and arrays of compile-time-unknown size)
static inline void
payload_to_dynamic_allocation_roots(enum event_type t,
                                    void *src_ptr,
                                    void *dst_ptr,
                                    struct dar_array *src_result,
                                    struct dar_array *dst_result)
{
  *src_result = (struct dar_array){0, NULL};
  *dst_result = (struct dar_array){0, NULL};
  switch (t)
  {
  case event_type_sched_sched_process_exec:
  {
    struct payload_kernel_sched_sched_process_exec *src = (struct payload_kernel_sched_sched_process_exec *)src_ptr;
    struct payload_user_sched_sched_process_exec *dst = (struct payload_user_sched_sched_process_exec *)dst_ptr;
    static u64 src_roots[1];
    static u64 dst_roots[1];
    src_roots[0] = (u64)&src->argv;
    dst_roots[0] = (u64)&dst->argv;
    *src_result = (struct dar_array){1, src_roots};
    *dst_result = (struct dar_array){1, dst_roots};
    break;
  }
  case event_type_syscalls_sys_enter_openat:
  {
    struct payload_kernel_syscalls_sys_enter_openat *src = (struct payload_kernel_syscalls_sys_enter_openat *)src_ptr;
    struct payload_user_syscalls_sys_enter_openat *dst = (struct payload_user_syscalls_sys_enter_openat *)dst_ptr;
    static u64 src_roots[1];
    static u64 dst_roots[1];
    src_roots[0] = (u64)&src->filename;
    dst_roots[0] = (u64)&dst->filename;
    *src_result = (struct dar_array){1, src_roots};
    *dst_result = (struct dar_array){1, dst_roots};
    break;
  }
  case event_type_syscalls_sys_enter_write:
  {
    struct payload_kernel_syscalls_sys_enter_write *src = (struct payload_kernel_syscalls_sys_enter_write *)src_ptr;
    struct payload_user_syscalls_sys_enter_write *dst = (struct payload_user_syscalls_sys_enter_write *)dst_ptr;
    static u64 src_roots[1];
    static u64 dst_roots[1];
    src_roots[0] = (u64)&src->content;
    dst_roots[0] = (u64)&dst->content;
    *src_result = (struct dar_array){1, src_roots};
    *dst_result = (struct dar_array){1, dst_roots};
    break;
  }
  default:
    break;
  }
}

// For the statically measurable part of payloads only
static inline size_t get_payload_fixed_size(enum event_type t)
{
  switch (t)
  {
  case event_type_sched_sched_process_exec:
    return sizeof(struct payload_kernel_sched_sched_process_exec);
  case event_type_sched_sched_process_exit:
    return sizeof(struct payload_kernel_sched_sched_process_exit);
  case event_type_sched_psi_memstall_enter:
    return sizeof(struct payload_kernel_sched_psi_memstall_enter);
  case event_type_syscalls_sys_enter_openat:
    return sizeof(struct payload_kernel_syscalls_sys_enter_openat);
  case event_type_syscalls_sys_exit_openat:
    return sizeof(struct payload_kernel_syscalls_sys_exit_openat);
  case event_type_syscalls_sys_enter_read:
    return sizeof(struct payload_kernel_syscalls_sys_enter_read);
  case event_type_syscalls_sys_enter_write:
    return sizeof(struct payload_kernel_syscalls_sys_enter_write);
  case event_type_vmscan_mm_vmscan_direct_reclaim_begin:
    return sizeof(struct payload_kernel_vmscan_mm_vmscan_direct_reclaim_begin);
  case event_type_oom_mark_victim:
    return sizeof(struct payload_kernel_oom_mark_victim);
  default:
    return 0;
  }
}

// -------
// Helpers for printing as JSON (in example.cpp)
// -------

static inline const char* event_type_to_string(enum event_type t)
{
  switch (t)
  {
  case event_type_sched_sched_process_exec:
    return "sched/sched_process_exec";
  case event_type_sched_sched_process_exit:
    return "sched/sched_process_exit";
  case event_type_sched_psi_memstall_enter:
    return "sched/psi_memstall_enter";
  case event_type_syscalls_sys_enter_openat:
    return "syscalls/sys_enter_openat";
  case event_type_syscalls_sys_exit_openat:
    return "syscalls/sys_exit_openat";
  case event_type_syscalls_sys_enter_read:
    return "syscalls/sys_enter_read";
  case event_type_syscalls_sys_enter_write:
    return "syscalls/sys_enter_write";
  case event_type_vmscan_mm_vmscan_direct_reclaim_begin:
    return "vmscan/mm_vmscan_direct_reclaim_begin";
  case event_type_oom_mark_victim:
    return "oom/mark_victim";
  default:
    return "unknown";
  }
}

struct kv_entry
{
  char type[32]; // eg, "u32"
  char key[32];  // eg, "filename"
  void *value;
};

struct kv_array
{
  u32 length;
  struct kv_entry *data;
};

static inline struct kv_array payload_to_kv_array(enum event_type t, void *ptr)
{
  struct kv_array result = {0, NULL};
  switch (t)
  {
  case event_type_sched_sched_process_exec:
  {
    struct payload_user_sched_sched_process_exec *p = (struct payload_user_sched_sched_process_exec *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "char[][]");
    strcpy(entries[0].key, "argv");
    entries[0].value = &p->argv;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_sched_sched_process_exit:
  {
    struct payload_user_sched_sched_process_exit *p = (struct payload_user_sched_sched_process_exit *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "exit_code");
    entries[0].value = &p->exit_code;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_sched_psi_memstall_enter:
    break;
  case event_type_syscalls_sys_enter_openat:
  {
    struct payload_user_syscalls_sys_enter_openat *p = (struct payload_user_syscalls_sys_enter_openat *)ptr;
    static struct kv_entry entries[4];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "dfd");
    entries[0].value = &p->dfd;
    strcpy(entries[1].type, "char[]");
    strcpy(entries[1].key, "filename");
    entries[1].value = &p->filename;
    strcpy(entries[2].type, "u32");
    strcpy(entries[2].key, "flags");
    entries[2].value = &p->flags;
    strcpy(entries[3].type, "u32");
    strcpy(entries[3].key, "mode");
    entries[3].value = &p->mode;
    result.length = 4;
    result.data = entries;
    break;
  }
  case event_type_syscalls_sys_exit_openat:
  {
    struct payload_user_syscalls_sys_exit_openat *p = (struct payload_user_syscalls_sys_exit_openat *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "fd");
    entries[0].value = &p->fd;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_syscalls_sys_enter_read:
  {
    struct payload_user_syscalls_sys_enter_read *p = (struct payload_user_syscalls_sys_enter_read *)ptr;
    static struct kv_entry entries[2];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "fd");
    entries[0].value = &p->fd;
    strcpy(entries[1].type, "u64");
    strcpy(entries[1].key, "count");
    entries[1].value = &p->count;
    result.length = 2;
    result.data = entries;
    break;
  }
  case event_type_syscalls_sys_enter_write:
  {
    struct payload_user_syscalls_sys_enter_write *p = (struct payload_user_syscalls_sys_enter_write *)ptr;
    static struct kv_entry entries[3];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "fd");
    entries[0].value = &p->fd;
    strcpy(entries[1].type, "u64");
    strcpy(entries[1].key, "count");
    entries[1].value = &p->count;
    strcpy(entries[2].type, "char[]");
    strcpy(entries[2].key, "content");
    entries[2].value = &p->content;
    result.length = 3;
    result.data = entries;
    break;
  }
  case event_type_vmscan_mm_vmscan_direct_reclaim_begin:
  {
    struct payload_user_vmscan_mm_vmscan_direct_reclaim_begin *p = (struct payload_user_vmscan_mm_vmscan_direct_reclaim_begin *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "order");
    entries[0].value = &p->order;
    result.length = 1;
    result.data = entries;
    break;
  }
  case event_type_oom_mark_victim:
  {
    struct payload_user_oom_mark_victim *p = (struct payload_user_oom_mark_victim *)ptr;
    static struct kv_entry entries[1];
    strcpy(entries[0].type, "u32");
    strcpy(entries[0].key, "_unused");
    entries[0].value = &p->_unused;
    result.length = 1;
    result.data = entries;
    break;
  }
  default:
    break;
  }
  return result;
}

#endif /* BOOTSTRAP_H */
