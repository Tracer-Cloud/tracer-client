/* ========================================================================== */
/*                           GENERATED FILE                                   */
/* ========================================================================== */
/*                                                                            */
/*  This file is automatically generated from types.templ.rs                 */
/*  DO NOT EDIT MANUALLY - changes will be overwritten                        */
/*                                                                            */
/*  Generator: ebpf/typegen/typegen.rs                                        */
/*  Template:  ebpf/rs/types.templ.rs                                         */
/*  Config:    ebpf/typegen/events.toml                                       */
/*                                                                            */
/*  To regenerate: `cd tracer-client/src/ebpf/c && make` (fast)               */
/*  Alternative:   `cd tracer-client && cargo build` (slower)                 */
/*                                                                            */
/* ========================================================================== */

use serde::{Deserialize, Serialize};
use std::os::raw::c_void;
use std::slice;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize)]
#[repr(u32)]
pub enum EventType {
    SchedSchedProcessExec = 0,
    SchedSchedProcessExit = 1,
    SchedPsiMemstallEnter = 16,
    SyscallsSysEnterOpenat = 1024,
    SyscallsSysExitOpenat = 1025,
    SyscallsSysEnterRead = 1026,
    SyscallsSysEnterWrite = 1028,
    VmscanMmVmscanDirectReclaimBegin = 2048,
    OomMarkVictim = 3072,
    // Add unknown variant for robustness
    Unknown(u32),
}

// High-level event header (converted from C)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventHeader {
    pub event_id: u64,
    pub event_type: EventType,
    pub timestamp_ns: u64,
    pub pid: u32,
    pub ppid: u32,
    pub upid: u64,
    pub uppid: u64,
    pub comm: String,
}

// Combined event structure with header and typed payload
#[derive(Debug, Clone, Deserialize)]
pub struct Event {
    pub header: EventHeader,
    pub payload: EventPayload,
}

// Custom serialization for Event to match example.cpp JSON format
impl Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;

        let mut map = serializer.serialize_map(None)?;

        // Serialize header fields directly
        map.serialize_entry("event_id", &self.header.event_id)?;
        map.serialize_entry("event_type", &self.header.event_type.as_str())?;
        map.serialize_entry("timestamp_ns", &self.header.timestamp_ns)?;
        map.serialize_entry("pid", &self.header.pid)?;
        map.serialize_entry("ppid", &self.header.ppid)?;
        map.serialize_entry("upid", &self.header.upid)?;
        map.serialize_entry("uppid", &self.header.uppid)?;
        map.serialize_entry("comm", &self.header.comm)?;

        // Only add payload if it's not empty
        if !matches!(self.payload, EventPayload::Empty) {
            map.serialize_entry("payload", &self.payload)?;
        }

        map.end()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EventPayload {
    Empty,
    SchedSchedProcessExec(SchedSchedProcessExecPayload),
    SchedSchedProcessExit(SchedSchedProcessExitPayload),
    SyscallsSysEnterOpenat(SyscallsSysEnterOpenatPayload),
    SyscallsSysExitOpenat(SyscallsSysExitOpenatPayload),
    SyscallsSysEnterRead(SyscallsSysEnterReadPayload),
    SyscallsSysEnterWrite(SyscallsSysEnterWritePayload),
    VmscanMmVmscanDirectReclaimBegin(VmscanMmVmscanDirectReclaimBeginPayload),
}

// Process execution (successful)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchedSchedProcessExecPayload {
    pub argv: Vec<String>,
}

// Process termination (successful)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchedSchedProcessExitPayload {
    pub exit_code: u32,
}

// File open, syscall entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyscallsSysEnterOpenatPayload {
    pub dfd: u32,
    pub filename: String,
    pub flags: u32,
    pub mode: u32,
}

// File open, syscall return
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyscallsSysExitOpenatPayload {
    pub fd: u32,
}

// Files and pipes, read syscall entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyscallsSysEnterReadPayload {
    pub fd: u32,
    pub count: u64,
}

// Files and pipes, write syscall entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyscallsSysEnterWritePayload {
    pub fd: u32,
    pub count: u64,
    pub content: String,
}

// Memory pressure, reclaim begins
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VmscanMmVmscanDirectReclaimBeginPayload {
    pub order: u32,
}


// C structures for payload conversion
#[repr(C, packed)]
struct FlexBuf {
    byte_length: u32,
    data: *mut i8,
}

// C struct for sched.sched_process_exec
#[repr(C, packed)]
struct CPayloadSchedSchedProcessExec {
    argv: FlexBuf,
}

// C struct for sched.sched_process_exit
#[repr(C, packed)]
struct CPayloadSchedSchedProcessExit {
    exit_code: u32,
}

// C struct for syscalls.sys_enter_openat
#[repr(C, packed)]
struct CPayloadSyscallsSysEnterOpenat {
    dfd: u32,
    filename: FlexBuf,
    flags: u32,
    mode: u32,
}

// C struct for syscalls.sys_exit_openat
#[repr(C, packed)]
struct CPayloadSyscallsSysExitOpenat {
    fd: u32,
}

// C struct for syscalls.sys_enter_read
#[repr(C, packed)]
struct CPayloadSyscallsSysEnterRead {
    fd: u32,
    count: u64,
}

// C struct for syscalls.sys_enter_write
#[repr(C, packed)]
struct CPayloadSyscallsSysEnterWrite {
    fd: u32,
    count: u64,
    content: FlexBuf,
}

// C struct for vmscan.mm_vmscan_direct_reclaim_begin
#[repr(C, packed)]
struct CPayloadVmscanMmVmscanDirectReclaimBegin {
    order: u32,
}


impl EventPayload {
    pub unsafe fn from_c_payload(event_type: u32, payload_ptr: *mut c_void) -> Self {
        match event_type {
            0 => {
                let c_payload = &*(payload_ptr as *const CPayloadSchedSchedProcessExec);
                EventPayload::SchedSchedProcessExec(SchedSchedProcessExecPayload {
                    argv: flex_buf_to_string_array(&c_payload.argv),
                })
            }
            1 => {
                let c_payload = &*(payload_ptr as *const CPayloadSchedSchedProcessExit);
                EventPayload::SchedSchedProcessExit(SchedSchedProcessExitPayload {
                    exit_code: c_payload.exit_code,
                })
            }
            1024 => {
                let c_payload = &*(payload_ptr as *const CPayloadSyscallsSysEnterOpenat);
                EventPayload::SyscallsSysEnterOpenat(SyscallsSysEnterOpenatPayload {
                    dfd: c_payload.dfd,
                    filename: flex_buf_to_string(&c_payload.filename),
                    flags: c_payload.flags,
                    mode: c_payload.mode,
                })
            }
            1025 => {
                let c_payload = &*(payload_ptr as *const CPayloadSyscallsSysExitOpenat);
                EventPayload::SyscallsSysExitOpenat(SyscallsSysExitOpenatPayload {
                    fd: c_payload.fd,
                })
            }
            1026 => {
                let c_payload = &*(payload_ptr as *const CPayloadSyscallsSysEnterRead);
                EventPayload::SyscallsSysEnterRead(SyscallsSysEnterReadPayload {
                    fd: c_payload.fd,
                    count: c_payload.count,
                })
            }
            1028 => {
                let c_payload = &*(payload_ptr as *const CPayloadSyscallsSysEnterWrite);
                EventPayload::SyscallsSysEnterWrite(SyscallsSysEnterWritePayload {
                    fd: c_payload.fd,
                    count: c_payload.count,
                    content: flex_buf_to_string(&c_payload.content),
                })
            }
            2048 => {
                let c_payload = &*(payload_ptr as *const CPayloadVmscanMmVmscanDirectReclaimBegin);
                EventPayload::VmscanMmVmscanDirectReclaimBegin(VmscanMmVmscanDirectReclaimBeginPayload {
                    order: c_payload.order,
                })
            }
            _ => EventPayload::Empty,
        }
    }
}

// Helper function to convert C string from FlexBuf
unsafe fn flex_buf_to_string(flex_buf: &FlexBuf) -> String {
    if flex_buf.data.is_null() || flex_buf.byte_length == 0 {
        return String::new();
    }

    let slice = slice::from_raw_parts(flex_buf.data as *const u8, flex_buf.byte_length as usize);
    // Find null terminator if present
    let len = slice.iter().position(|&b| b == 0).unwrap_or(slice.len());
    String::from_utf8_lossy(&slice[..len]).into_owned()
}

// Helper function to convert C string array from FlexBuf (null-separated strings)
unsafe fn flex_buf_to_string_array(flex_buf: &FlexBuf) -> Vec<String> {
    if flex_buf.data.is_null() || flex_buf.byte_length == 0 {
        return Vec::new();
    }

    let slice = slice::from_raw_parts(flex_buf.data as *const u8, flex_buf.byte_length as usize);
    let mut result = Vec::new();
    let mut start = 0;

    for i in 0..=slice.len() {
        if i == slice.len() || slice[i] == 0 {
            if i > start {
                let string = String::from_utf8_lossy(&slice[start..i]).into_owned();
                result.push(string);
            }
            start = i + 1;
        }
    }

    result
}

impl From<u32> for EventType {
    fn from(value: u32) -> Self {
        match value {
            0 => EventType::SchedSchedProcessExec,
            1 => EventType::SchedSchedProcessExit,
            16 => EventType::SchedPsiMemstallEnter,
            1024 => EventType::SyscallsSysEnterOpenat,
            1025 => EventType::SyscallsSysExitOpenat,
            1026 => EventType::SyscallsSysEnterRead,
            1028 => EventType::SyscallsSysEnterWrite,
            2048 => EventType::VmscanMmVmscanDirectReclaimBegin,
            3072 => EventType::OomMarkVictim,
            unknown => EventType::Unknown(unknown),
        }
    }
}

impl EventType {
    pub fn as_str(&self) -> &'static str {
        match self {
            EventType::SchedSchedProcessExec => "sched/sched_process_exec",
            EventType::SchedSchedProcessExit => "sched/sched_process_exit",
            EventType::SchedPsiMemstallEnter => "sched/psi_memstall_enter",
            EventType::SyscallsSysEnterOpenat => "syscalls/sys_enter_openat",
            EventType::SyscallsSysExitOpenat => "syscalls/sys_exit_openat",
            EventType::SyscallsSysEnterRead => "syscalls/sys_enter_read",
            EventType::SyscallsSysEnterWrite => "syscalls/sys_enter_write",
            EventType::VmscanMmVmscanDirectReclaimBegin => "vmscan/mm_vmscan_direct_reclaim_begin",
            EventType::OomMarkVictim => "oom/mark_victim",
            EventType::Unknown(_) => "unknown",
        }
    }
}

// Custom Serialize implementation to handle Unknown variant properly
impl Serialize for EventType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            EventType::Unknown(val) => serializer.serialize_str(&format!("unknown({})", val)),
            _ => serializer.serialize_str(self.as_str()),
        }
    }
}
